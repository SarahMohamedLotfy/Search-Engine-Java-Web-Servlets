How to find time complexity of an algorithm - Stack Overflow , Stack Overflow Products Customers Use cases Log in Sign up , Stack Overflow Products Customers Use cases Log in Sign up By using our site, you acknowledge that you have read and understand our Cookie Policy, Privacy Policy, and our Terms of Service. Home Public Stack Overflow Tags Users Find a Job Jobs Companies Teams What’s this? Free 30 Day Trial How to find time complexity of an algorithm Ask Question Asked 8 years ago Active 1 month ago Viewed 685k times This question shows research effort; it is useful and clear 893 This question does not show any research effort; it is unclear or not useful 654 Bookmark this question. Show activity on this post. The Question How to find time complexity of an algorithm? What have I done before posting a question on SO ? I have gone through this, this and many other links But no where I was able to find a clear and straight forward explanation for how to calculate time complexity. What do I know ? Say for a code as simple as the one below: char h = 'y'; // This will be executed 1 time
int abc = 0; // This will be executed 1 time
 Say for a loop like the one below: for (int i = 0; i < N; i++) {        
    Console.Write('Hello World !');
}
 int i=0; This will be executed only once. The time is actually calculated to i=0 and not the declaration. i < N; This will be executed N+1 times i++ ; This will be executed N times So the number of operations required by this loop are {1+(N+1)+N} = 2N+2 Note: This still may be wrong, as I am not confident about my understanding on calculating time complexity What I want to know ? Ok, so these small basic calculations I think I know, but in most cases I have seen the time complexity as O(N), O(n2), O(log n), O(n!).... and many other, Can anyone help me understand how does one calculate time complexity of an algorithm? I am sure there are plenty of newbies like me wanting to know this. algorithm time-complexity complexity-theory share | improve this question | follow Follow this question to receive notifications | edited Oct 27 '17 at 7:38 Kushal 6,01866 gold badges4343 silver badges6666 bronze badges asked Jun 14 '12 at 11:21 Yasser ShaikhYasser Shaikh 41.8k4141 gold badges181181 silver badges264264 bronze badges 139 Bonus for those interested: The Big O Cheat Sheet bigocheatsheet.com – msanford Jun 9 '13 at 22:12 4 Check this blog out: mohalgorithmsorbit.blogspot.com. It covers both recursive and (especially) iterative algorithms. – Mohamed Ennahdi El Idrissi Mar 5 '15 at 0:10 1 why is Console.Write('Hello World !'); not a machine instruction? – Chetan Jul 10 '17 at 11:02 Related / maybe duplicate: Big O, how do you calculate/approximate it? – Bernhard Barker Dec 24 '17 at 17:24 1 @Chetan If you mean that you should consider Console.Write when calculating the complexity, that's true, but also somewhat irrelevant in this case, as that only changes a constant factor, which big-O ignores (see the answers), so the end result is still a complexity of O(N). – Bernhard Barker Dec 24 '17 at 17:39 | show 1 more comment 9 Answers 9 Active Oldest Votes This answer is useful 399 This answer is not useful Say thanks for this answer. 1 1 other reacted with thanks. Show activity on this post. How to find time complexity of an algorithm You add up how many machine instructions it will execute as a function of the size of its input, and then simplify the expression to the largest (when N is very large) term and can include any simplifying constant factor. For example, lets see how we simplify 2N + 2 machine instructions to describe this as just O(N). Why do we remove the two 2s ? We are interested in the performance of the algorithm as N becomes large. Consider the two terms 2N and 2. What is the relative influence of these two terms as N becomes large? Suppose N is a million. Then the first term is 2 million and the second term is only 2. For this reason, we drop all but the largest terms for large N. So, now we have gone from 2N + 2 to 2N. Traditionally, we are only interested in performance up to constant factors. This means that we don't really care if there is some constant multiple of difference in performance when N is large. The unit of 2N is not well-defined in the first place anyway. So we can multiply or divide by a constant factor to get to the simplest expression. So 2N becomes just N. share | improve this answer | follow Follow this answer to receive notifications | edited Mar 29 '17 at 11:43 JJJ 30.8k1616 gold badges8181 silver badges9696 bronze badges answered Jun 14 '12 at 11:25 Andrew TomazosAndrew Tomazos 54.7k3131 gold badges148148 silver badges252252 bronze badges 53 hey thanks for letting me know "why O(2N+2) to O(N)" very nicely explained, but this was only a part of the bigger question, I wanted someone to point out to some link to a hidden resource or in general I wanted to know how to do you end up with time complexities like O(N), O(n2), O(log n), O(n!), etc.. I know I may be asking a lot, but still I can try :{) – Yasser Shaikh Jun 14 '12 at 11:33 3 Well the complexity in the brackets is just how long the algorithm takes, simplified using the method I have explained. We work out how long the algorithm takes by simply adding up the number of machine instructions it will execute. We can simplify by only looking at the busiest loops and dividing by constant factors as I have explained. – Andrew Tomazos Jun 14 '12 at 11:36 4 Giving an in-answer example would have helped a lot, for future readers. Just handing over a link for which I have to signup, really doesn't help me when I just want to go through some nicely explained text. – bad_keypoints Jan 2 '16 at 4:48 2 I would suggest to watch Dr. Naveen Garg(IIT Delhi Prof.) videos if you want to get good knowledge on DS and Time complexity.check the link.nptel.ac.in/courses/106102064 – Rohit Bandil Oct 1 '16 at 16:45 2 (cont.) This hierarchy would have a height on the order of log N. As for O(N!) my analogies won't likely cut it, but permutations are on that order - it's prohibitively steep, more so than any polynomial or exponential. There are exactly 10! seconds in six weeks but the universe is less than 20! seconds old. – John P Feb 25 '18 at 2:59 | show 6 more comments