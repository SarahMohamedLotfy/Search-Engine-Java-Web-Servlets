Greedy algorithm - Wikipedia ,  , Greedy algorithm From Wikipedia, the free encyclopedia Jump to navigation Jump to search Greedy algorithms determine minimum number of coins to give while making change. These are the steps a human would take to emulate a greedy algorithm to represent 36 cents using only coins with values {1, 5, 10, 20}. The coin of the highest value, less than the remaining change owed, is the local optimum. (In general the change-making problem requires dynamic programming to find an optimal solution; however, most currency systems, including the Euro and US Dollar, are special cases where the greedy strategy does find an optimal solution.) A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage[1] with the intent of finding a global optimum. In many problems, a greedy strategy does not usually produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time. For example, a greedy strategy for the travelling salesman problem (which is of a high computational complexity) is the following heuristic: "At each step of the journey, visit the nearest unvisited city." This heuristic does not intend to find a best solution, but it terminates in a reasonable number of steps; finding an optimal solution to such a complex problem typically requires unreasonably many steps. In mathematical optimization, greedy algorithms optimally solve combinatorial problems having the properties of matroids, and give constant-factor approximations to optimization problems with submodular structure. Contents 1 Specifics 1.1 Cases of failure 2 Types 3 Theory 3.1 Matroids 3.2 Submodular functions 3.3 Other problems with guarantees 4 Applications 5 Examples 6 See also 7 Notes 8 References 9 External links Specifics[edit] In general, greedy algorithms have five components: A candidate set, from which a solution is created A selection function, which chooses the best candidate to be added to the solution A feasibility function, that is used to determine if a candidate can be used to contribute to a solution An objective function, which assigns a value to a solution, or a partial solution, and A solution function, which will indicate when we have discovered a complete solution Greedy algorithms produce good solutions on some mathematical problems, but not on others. Most problems for which they work will have two properties: Greedy choice property We can make whatever choice seems best at the moment and then solve the subproblems that arise later. The choice made by a greedy algorithm may depend on choices made so far, but not on future choices or all the solutions to the subproblem. It iteratively makes one greedy choice after another, reducing each given problem into a smaller one. In other words, a greedy algorithm never reconsiders its choices. This is the main difference from dynamic programming, which is exhaustive and is guaranteed to find the solution. After every stage, dynamic programming makes decisions based on all the decisions made in the previous stage, and may reconsider the previous stage's algorithmic path to solution. Optimal substructure "A problem exhibits optimal substructure if an optimal solution to the problem contains optimal solutions to the sub-problems."[2] Cases of failure[edit] Examples on how a greedy algorithm may fail to achieve the optimal solution. Starting from A, a greedy algorithm that tries to find the maximum by following the greatest slope will find the local maximum at "m", oblivious to the global maximum at "M". With a goal of reaching the largest sum, at each step, the greedy algorithm will choose what appears to be the optimal immediate choice, so it will choose 12 instead of 3 at the second step, and will not reach the best solution, which contains 99. For many other problems, greedy algorithms fail to produce the optimal solution, and may even produce the unique worst possible solution. One example is the traveling salesman problem mentioned above: for each number of cities, there is an assignment of distances between the cities for which the nearest-neighbor heuristic produces the unique worst possible tour.[3] Types[edit] This section needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. Find sources: "Greedy algorithm" – news · newspapers · books · scholar · JSTOR (June 2018) (Learn how and when to remove this template message) Greedy algorithms can be characterized as being 'short sighted', and also as 'non-recoverable'. They are ideal only for problems which have 'optimal substructure'. Despite this, for many simple problems, the best suited algorithms are greedy algorithms. It is important, however, to note that the greedy algorithm can be used as a selection algorithm to prioritize options within a search, or branch-and-bound algorithm. There are a few variations to the greedy algorithm: Pure greedy algorithms Orthogonal greedy algorithms Relaxed greedy algorithms Theory[edit] Greedy algorithms have a long history of study in combinatorial optimization and theoretical computer science. Greedy heuristics are known to produce suboptimal results on many problems,[4] and so natural questions are: For which problems do greedy algorithms perform optimally? For which problems do greedy algorithms guarantee an approximately optimal solution? For which problems is the greedy algorithm guaranteed not to produce an optimal solution? A large body of literature exists answering these questions for general classes of problems, such as matroids, as well as for specific problems, such as set cover. Matroids[edit] Main article: Matroid A matroid is a mathematical structure that generalizes the notion of linear independence from vector spaces to arbitrary sets. If an optimization problem has the structure of a matroid, then the appropriate greedy algorithm will solve it optimally.[5] Submodular functions[edit] Main article: Submodular set function § Optimization problems A function f {\displaystyle f} defined on subsets of a set Ω {\displaystyle \Omega } is called submodular if for every S , T ⊆ Ω {\displaystyle S,T\subseteq \Omega } we have that f ( S ) + f ( T ) ≥ f ( S ∪ T ) + f ( S ∩ T ) {\displaystyle f(S)+f(T)\geq f(S\cup T)+f(S\cap T)} . Suppose one wants to find a set S {\displaystyle S} which maximizes f {\displaystyle f} . The greedy algorithm, which builds up a set S {\displaystyle S} by incrementally adding the element which increases f {\displaystyle f} the most at each step, produces as output a set that is at least ( 1 − 1 / e ) max X ⊆ Ω f ( X ) {\displaystyle (1-1/e)\max _{X\subseteq \Omega }f(X)} .[6] That is, greedy performs within a constant factor of ( 1 − 1 / e ) ≈ 0.63 {\displaystyle (1-1/e)\approx 0.63} as good as the optimal solution. Similar guarantees are provable when additional constraints, such as cardinality constraints,[7] are imposed on the output, though often slight variations on the greedy algorithm are required. See [8] for an overview. Other problems with guarantees[edit] Other problems for which the greedy algorithm gives a strong guarantee, but not an optimal solution, include Set cover The Steiner tree problem Load balancing[9] Independent set Many of these problems have matching lower bounds; i.e., the greedy algorithm does not perform better, in the worst case, than the guarantee. Applications[edit] This section needs expansion. You can help by adding to it. (June 2018) Greedy algorithms mostly (but not always) fail to find the globally optimal solution because they usually do not operate exhaustively on all the data. They can make commitments to certain choices too early which prevent them from finding the best overall solution later. For example, all known greedy coloring algorithms for the graph coloring problem and all other NP-complete problems do not consistently find optimum solutions. Nevertheless, they are useful because they are quick to think up and often give good approximations to the optimum. If a greedy algorithm can be proven to yield the global optimum for a given problem class, it typically becomes the method of choice because it is faster than other optimization methods like dynamic programming. Examples of such greedy algorithms are Kruskal's algorithm and Prim's algorithm for finding minimum spanning trees, and the algorithm for finding optimum Huffman trees. Greedy algorithms appear in network routing as well. Using greedy routing, a message is forwarded to the neighboring node which is "closest" to the destination. The notion of a node's location (and hence "closeness") may be determined by its physical location, as in geographic routing used by ad hoc networks. Location may also be an entirely artificial construct as in small world routing and distributed hash table. Examples[edit] The activity selection problem is characteristic to this class of problems, where the goal is to pick the maximum number of activities that do not clash with each other. In the Macintosh computer game Crystal Quest the objective is to collect crystals, in a fashion similar to the travelling salesman problem. The game has a demo mode, where the game uses a greedy algorithm to go to every crystal. The artificial intelligence does not account for obstacles, so the demo mode often ends quickly. The matching pursuit is an example of greedy algorithm applied on signal approximation. A greedy algorithm finds the optimal solution to Malfatti's problem of finding three disjoint circles within a given triangle that maximize the total area of the circles; it is conjectured that the same greedy algorithm is optimal for any number of circles. A greedy algorithm is used to construct a Huffman tree during Huffman coding where it finds an optimal solution. In decision tree learning, greedy algorithms are commonly used, however they are not guaranteed to find the optimal solution. One popular such algorithm is the ID3 algorithm for decision tree construction. Dijkstra's algorithm and the related A* search algorithm are verifiably optimal greedy algorithms for graph search and shortest path finding. A* search is conditionally optimal, requiring an "admissible heuristic" that will not overestimate path costs. Kruskal's algorithm and Prim's algorithm are greedy algorithms for constructing minimum spanning trees of a given connected graph. They always find an optimal solution, which may not be unique in general. See also[edit] Mathematics portal Epsilon-greedy strategy Greedy algorithm for Egyptian fractions Greedy source Matroid Best-first search Notes[edit] ^ Black, Paul E. (2 February 2005). "greedy algorithm". Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology (NIST). Retrieved 17 August 2012. line feed character in |publisher= at position 103 (help) ^ Introduction to Algorithms (Cormen, Leiserson, Rivest, and Stein) 2001, Chapter 16 "Greedy Algorithms". ^ Gutin, Gregory; Yeo, Anders; Zverovich, Alexey (2002). "Traveling salesman should not be greedy: Domination analysis of greedy-type heuristics for the TSP". Discrete Applied Mathematics. 117 (1–3): 81–86. doi:10.1016/S0166-218X(01)00195-0. ^ U. Feige. A threshold of ln n for approximating set cover. Journal of the ACM (JACM), 45(4):634–652, 1998. ^ Papadimitriou, Christos H., and Kenneth Steiglitz. Combinatorial optimization: algorithms and complexity. Courier Corporation, 1998. ^ G. Nemhauser, L.A. Wolsey, and M.L. Fisher. "An analysis of approximations for maximizing submodular set functions—I." Mathematical Programming 14.1 (1978): 265-294. ^ N. Buchbinder, et al. "Submodular maximization with cardinality constraints." Proceedings of the twenty-fifth annual ACM-SIAM symposium on Discrete algorithms. Society for Industrial and Applied Mathematics, 2014. ^ Krause, Andreas, and Daniel Golovin. "Submodular function maximization." (2014): 71-104. ^ http://www.win.tue.nl/~mdberg/Onderwijs/AdvAlg_Material/Course%20Notes/lecture5.pdf References[edit] Introduction to Algorithms (Cormen, Leiserson, Rivest, and Stein) 2001, Chapter 16 "Greedy Algorithms". Gutin, Gregory; Yeo, Anders; Zverovich, Alexey (2002). "Traveling salesman should not be greedy: Domination analysis of greedy-type heuristics for the TSP". Discrete Applied Mathematics. 117 (1–3): 81–86. doi:10.1016/S0166-218X(01)00195-0. Bang-Jensen, Jørgen; Gutin, Gregory; Yeo, Anders (2004). "When the greedy algorithm fails". Discrete Optimization. 1 (2): 121–127. doi:10.1016/j.disopt.2004.03.007. Bendall, Gareth; Margot, François (2006). "Greedy-type resistance of combinatorial problems". Discrete Optimization. 3 (4): 288–298. doi:10.1016/j.disopt.2006.03.001. U. Feige. A threshold of ln n for approximating set cover. Journal of the ACM (JACM), 45(4):634–652, 1998. G. Nemhauser, L.A. Wolsey, and M.L. Fisher. "An analysis of approximations for maximizing submodular set functions—I." Mathematical Programming 14.1 (1978): 265-294. N. Buchbinder, et al. "Submodular maximization with cardinality constraints." Proceedings of the twenty-fifth annual ACM-SIAM symposium on Discrete algorithms. Society for Industrial and Applied Mathematics, 2014. A. Krause and D. Golovin. "Submodular function maximization." (2014): 71-104. External links[edit] Wikimedia Commons has media related to Greedy algorithms. Hazewinkel, Michiel, ed. (2001) [1994], "Greedy algorithm", Encyclopedia of Mathematics, Springer Science+Business Media B.V. / Kluwer Academic Publishers, ISBN 978-1-55608-010-4 Python greedy coin example by Noah Gift. hide v t e Optimization: Algorithms, methods, and heuristics show Unconstrained nonlinear Functions Golden-section search Interpolation methods Line search Nelder–Mead method Successive parabolic interpolation Gradients Convergence Trust region Wolfe conditions Quasi–Newton Berndt–Hall–Hall–Hausman Broyden–Fletcher–Goldfarb–Shanno and L-BFGS Davidon–Fletcher–Powell Symmetric rank-one (SR1) Other methods Conjugate gradient Gauss–Newton Gradient Levenberg–Marquardt Powell's dog leg method Truncated Newton Hessians Newton's method show Constrained nonlinear General Barrier methods Penalty methods Differentiable Augmented Lagrangian methods Sequential quadratic programming Successive linear programming show Convex optimization Convex minimization Cutting-plane method Reduced gradient (Frank–Wolfe) Subgradient method Linear and quadratic Interior point Affine scaling Ellipsoid algorithm of Khachiyan Projective algorithm of Karmarkar Basis-exchange Simplex algorithm of Dantzig Revised simplex algorithm Criss-cross algorithm Principal pivoting algorithm of Lemke hide Combinatorial Paradigms Approximation algorithm Dynamic programming Greedy algorithm Integer programming Branch and bound/cut Graph algorithms Minimum spanning tree Borůvka Prim Kruskal Bellman–Ford Dijkstra Floyd–Warshall Network flows Dinic Edmonds–Karp Ford–Fulkerson Push–relabel maximum flow show Metaheuristics Evolutionary algorithm Hill climbing Local search Simulated annealing Tabu search Software Retrieved from "https://en.wikipedia.org/w/index.php?title=Greedy_algorithm&oldid=965526925" Categories: Optimization algorithms and methods Combinatorial algorithms Matroid theory Exchange algorithms Hidden categories: CS1 errors: invisible characters Articles needing additional references from June 2018 All articles needing additional references Articles to be expanded from June 2018 All articles to be expanded Articles using small message boxes Commons category link is on Wikidata Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Wikipedia store Contribute Help Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Wikidata item Cite this page In other projects Wikimedia Commons Print/export Download as PDF Printable version Languages العربية Azərbaycanca Català Čeština Dansk Deutsch Español Euskara فارسی Français 한국어 Italiano עברית Magyar Монгол 日本語 Norsk bokmål Polski Português Română Русский Simple English Slovenčina Slovenščina Српски / srpski Suomi Svenska ไทย Українська Tiếng Việt 中文22 more Edit links This page was last edited on 1 July 2020, at 21:09 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Statistics Cookie statement Mobile view Enable previews